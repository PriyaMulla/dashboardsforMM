<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Confocal Fluorescence Microscope &mdash; Time Tagger User Manual 2.16.2.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/plot_directive.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/iconTT.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Remote Time Tagger with Python" href="TimeTaggerRPC.html" />
    <link rel="prev" title="Tutorials" href="index.html" />
 
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-WXS6LN3');</script>
<!-- End Google Tag Manager -->

</head>

<body class="wy-body-for-nav">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WXS6LN3"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
 

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


          
          
          <a href="../index.html" class="icon icon-home">
            Time Tagger User Manual
              <img src="../_static/logo_white.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.16.2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

<div id="link_documentation_pdf" style="margin-top:20px;">
    <a style="font-weight:normal;color:#fcfcfc" target="_blank" href="/static/downloads/TimeTagger_User_Manual.pdf">
<svg version="1.1"  width="13px" height="14px" viewBox="0 0 13 14" xmlns="http://www.w3.org/2000/svg">
<g id="Download" fill="#fff">
<path d="m10 6.5-0.74-0.76-2.4 2.4v-8.2h-1.1v8.2l-2.4-2.4-0.74 0.76 3.6 3.6z"></path>
<path d="m1.1 13v-2.7h-1.1v3.8h13v-3.9h-1.1v2.9z"></path>
</g>
</svg>
        Documentation as pdf
    </a>
</div>
<script>
    // Hide the pdf download link when we detect that the file is served from the local file system.
    // Mostly likly to identify the ttlab offline documentation browser
    if(window.location.protocol === "file:") {
        document.getElementById("link_documentation_pdf").style.display = "none";
    }
</script>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../sections/gettingStarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sections/installation.html">Installation instructions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Confocal Fluorescence Microscope</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#time-tagger-configuration">Time Tagger configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#intensity-scanning-microscope">Intensity scanning microscope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fluorescence-lifetime-microscope">Fluorescence Lifetime Microscope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternative-pixel-trigger-formats">Alternative pixel trigger formats</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pixel-pulse-width-defines-the-integration-time">Pixel pulse width defines the integration time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pixel-pulse-indicates-the-pixel-start">Pixel pulse indicates the pixel start</a></li>
<li class="toctree-l4"><a class="reference internal" href="#flim-with-non-periodic-pixel-trigger">FLIM with non-periodic pixel trigger</a></li>
<li class="toctree-l4"><a class="reference internal" href="#line-pulse-but-no-pixel-pulses">Line pulse but no pixel pulses</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="TimeTaggerRPC.html">Remote Time Tagger with Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../synchronizer/index.html">Synchronizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sections/hardware.html">Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sections/software.html">Software Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">Application Programmer’s Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../InDepthGuides/index.html">In Depth Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sections/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sections/UsageStatistics.html">Usage Statistics Collection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sections/changelog.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Time Tagger User Manual</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Tutorials</a></li>
      <li class="breadcrumb-item active">Confocal Fluorescence Microscope</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="confocal-fluorescence-microscope">
<h1>Confocal Fluorescence Microscope<a class="headerlink" href="#confocal-fluorescence-microscope" title="Permalink to this heading"></a></h1>
<p>This tutorial guides you through setting up a data acquisition for a typical confocal microscope controlled with Swabian Instruments’ Time Tagger.
In this tutorial, we will use Time Tagger’s programming interface to define the data acquisition part of a scanning microscope. We will make no specific assumption of how the position scanning system is implemented except that it has to provide suitable signals detailed in the text.</p>
<p>The basic principle of confocal microscopy is that the light, collected from a sample, is spatially filtered by a confocal aperture, and only photons from a single spot of a sample can reach the detector. Compared to conventional microscopy, confocal microscopy offers several advantages, such as increased image contrast and better depth resolution, because the pinhole eliminates all out-of-focus photons, including stray light.</p>
<p>The following drawing shows a typical confocal fluorescence microscope setup.</p>
<a class="reference internal image-reference" href="../_images/confocal-microscope-setup.png"><img alt="../_images/confocal-microscope-setup.png" class="align-center" src="../_images/confocal-microscope-setup.png" style="width: 90%;" /></a>
<p>In this setup, the objective focuses the excitation light from the laser at the fluorescent sample and, at the same time, collects the resulting emission. The emission photons pass through the confocal aperture and arrive at the single-photon detector (SPD). For every detected photon, the SPD produces a voltage pulse at its output, namely a photon pulse.</p>
<p class="rubric">Image from a raster scan</p>
<p>In the confocal microscopy, the detection area is a small diffraction-limited spot. Therefore, to record an image, one has to scan the sample surface point-by-point and record the detector signal at every location.
The majority of scanning microscopes employ a raster scan path that visits every point on sample step-by-step and line-by-line. The figure below visualizes the travel path in a typical raster scan.</p>
<a class="reference internal image-reference" href="../_images/raster-scan-path.svg"><img alt="../_images/raster-scan-path.svg" class="align-center" src="../_images/raster-scan-path.svg" width="60%" /></a>
<p>In the figure above, the scan starts from the bottom-left corner and proceeds horizontally in steps.
At each scan position, the scanner has to wait for arbitrary integration time to allow sufficient photon collection.
This process stops when the scanner reaches the top-right point.</p>
<p>Along the scan path, the positioner generates a pulse for every new sample position.  In the following text, we will call this signal a pixel pulse.</p>
<p>To measure a confocal fluorescence image, the arrival times of the following three signals must be recorded:  photon pulses, laser pulses, and pixel pulses.</p>
<section id="time-tagger-configuration">
<h2>Time Tagger configuration<a class="headerlink" href="#time-tagger-configuration" title="Permalink to this heading"></a></h2>
<p>The Time Tagger library includes several measurement classes designed for confocal microscopy.</p>
<p>We will start by defining channel numbers and store them in variables for convenience.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PIXEL_START_CH</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Rising edge on input 1</span>
<span class="n">PIXEL_END_CH</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Falling edge on input 1</span>
<span class="n">LASER_CH</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">SPD_CH</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Now let’s connect to the Time Tagger.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tt</span> <span class="o">=</span> <span class="n">createTimeTagger</span><span class="p">()</span>
</pre></div>
</div>
<p>The Time Tagger hardware allows you to specify a trigger level voltage for each input channel. This trigger level, always applies for both, rising and falling edges of an input pulse. Whenever the signal level crosses this trigger level, the Time Tagger detects this as an event and stores the timestamp.
It is convenient to set the trigger level to half a signal amplitude.
For example, if your laser sync output provides pulses of 0.2 Volt amplitude, we set the trigger level to 0.1 V on this channel.
The default trigger level is 0.5 Volt.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tt</span><span class="o">.</span><span class="n">setTriggerLevel</span><span class="p">(</span><span class="n">PIXEL_START_CH</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">tt</span><span class="o">.</span><span class="n">setTriggerLevel</span><span class="p">(</span><span class="n">LASER_CH</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>The Time Tagger allows for delay compensation at each channel. Such delays are inevitably present in every measurement setup due to different cable lengths or inherent delays in the detectors and laser sync signals. It is worth noting that a typical coaxial cable has a signal propagation delay of about 5 ns/m.</p>
<p>Let’s suppose that we have to delay the laser pulse by 6.3 ns, if we want to align it close to the arrival time of the fluorescence photon pulse.
Using the Time Tagger’s API, this will look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tt</span><span class="o">.</span><span class="n">setInputDelay</span><span class="p">(</span><span class="n">LASER_CH</span><span class="p">,</span> <span class="mi">6300</span><span class="p">)</span>  <span class="c1"># Delay is always specified in picoseconds</span>
<span class="n">tt</span><span class="o">.</span><span class="n">setInputDelay</span><span class="p">(</span><span class="n">SPD_CH</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>       <span class="c1"># Default value is: 0</span>
</pre></div>
</div>
<p>Now we are finished with setting up the Time Tagger hardware and are ready to proceed with defining the measurements.</p>
</section>
<section id="intensity-scanning-microscope">
<h2>Intensity scanning microscope<a class="headerlink" href="#intensity-scanning-microscope" title="Permalink to this heading"></a></h2>
<p>In this section, we start from an easy example of only counting the number of photons per pixel and spend some time on understanding how to use the pixel trigger signal. The Time Tagger library contains the generic <a class="reference internal" href="../api/Measurements.html#api-countbetweenmarkers"><span class="std std-ref">CountBetweenMarkers</span></a> measurement that has all the necessary functionality to implement the data acquisition for a scanning microscope.</p>
<p>For the <a class="reference internal" href="../api/Measurements.html#api-countbetweenmarkers"><span class="std std-ref">CountBetweenMarkers</span></a> measurement, you have to specify on which channels the photon and the pixel pulses arrive. Also, we have to specify the total number of points in the scan, which is the number of pixels in the final image. Furthermore, we assume that the pixel pulse edges indicate when to start, and when to stop counting photons and the pulse duration defines the integration time. If your scanning system generates pixel pulses of a different format, take a look at the section <a class="reference internal" href="#alternative-pixel-trigger-formats"><span class="std std-ref">Alternative pixel trigger formats</span></a>.</p>
<p>As a first step, we create a measurement object with all the necessary parameters provided.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nx_pix</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">ny_pix</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">n_pixels</span> <span class="o">=</span> <span class="n">nx_pix</span> <span class="o">*</span> <span class="n">ny_pix</span>

<span class="n">cbm</span> <span class="o">=</span> <span class="n">CountBetweenMarkers</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">SPD_CH</span><span class="p">,</span> <span class="n">PIXEL_START_CH</span><span class="p">,</span> <span class="n">PIXEL_STOP_CH</span><span class="p">,</span> <span class="n">n_pixels</span><span class="p">)</span>
</pre></div>
</div>
<p>The measurement is now prepared and waiting for the signals to arrive.
The next step is to send a command to the piezo-positioner to start scanning and producing the pixel pulses for each location.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scanner</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx_pix</span><span class="p">,</span>
    <span class="n">y0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">ny_pix</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The code above introduces a <cite>scanner</cite> object which is not part of the
Time Tagger library. It is an example of a hypothetical programming interface for a piezo-scanner. Here, we also assume that this call is non-blocking, and the script can continue immediately after starting the scan.</p>
</div>
<p>After we started the scanner, the Time Tagger receives the pixel pulses, counts the events at each pixel, and stores the count in its internal buffer. One can read the buffer content periodically without disturbing the acquisition, even before the measurement is completed. Therefore, you can see the intermediate results and visualize the scan progress.</p>
<p>The resulting data from the <a class="reference internal" href="../api/Measurements.html#api-countbetweenmarkers"><span class="std std-ref">CountBetweenMarkers</span></a> measurement is a vector. We have to reorganize the elements of this vector according to the scan path if we want to display it as an image. For the raster scan, this reorganization can be done by a simple reshaping of the vector into a 2D array.</p>
<p>The following code gives you an example of how you can visualize the scan process.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">scanner</span><span class="o">.</span><span class="n">isScanning</span><span class="p">():</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">cbm</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">nx_pix</span><span class="p">,</span> <span class="n">ny_pix</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="fluorescence-lifetime-microscope">
<h2>Fluorescence Lifetime Microscope<a class="headerlink" href="#fluorescence-lifetime-microscope" title="Permalink to this heading"></a></h2>
<p>In the section <a class="reference internal" href="#intensity-scanning-microscope">Intensity scanning microscope</a>, we completely discarded the time of arrival for photon and laser pulses. The Time Tagger allows you to record a fluorescence decay histogram for every pixel of the confocal image by taking into account the time difference between the arrival of the photon and laser pulses.
This task can be achieved using the <a class="reference internal" href="../api/Measurements.html#api-timedifferences"><span class="std std-ref">TimeDifferences</span></a> measurement from the Time Tagger library. In this subsection, we will use the <a class="reference internal" href="../api/Measurements.html#api-timedifferences"><span class="std std-ref">TimeDifferences</span></a> measurement.</p>
<p>The <a class="reference internal" href="../api/Measurements.html#api-timedifferences"><span class="std std-ref">TimeDifferences</span></a> measurement calculates the time differences between laser and photon pulses and accumulates them in a histogram for every pixel. The measurement class constructor requires imaging and timing parameters, as shown in the following code snippet.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nx_pix</span> <span class="o">=</span> <span class="mi">300</span>   <span class="c1"># Number of pixels along x-axis</span>
<span class="n">ny_pix</span> <span class="o">=</span> <span class="mi">200</span>   <span class="c1"># Number of pixels along y-axis</span>
<span class="n">binwidth</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># in picoseconds</span>
<span class="n">n_bins</span> <span class="o">=</span> <span class="mi">2000</span>  <span class="c1"># number of bins in a histogram</span>
<span class="n">n_pixels</span> <span class="o">=</span> <span class="n">nx_pix</span> <span class="o">*</span> <span class="n">ny_pix</span> <span class="c1"># number of histograms</span>

<span class="n">flim</span> <span class="o">=</span> <span class="n">TimeDifferences</span><span class="p">(</span>
    <span class="n">tt</span><span class="p">,</span>
    <span class="n">click_channel</span><span class="o">=</span><span class="n">SPD_CH</span><span class="p">,</span>
    <span class="n">start_channel</span><span class="o">=</span><span class="n">LASER_CH</span><span class="p">,</span>
    <span class="n">next_channel</span><span class="o">=</span><span class="n">PIXEL_START_CH</span><span class="p">,</span>
    <span class="n">binwidth</span><span class="o">=</span><span class="n">binwidth</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span>
    <span class="n">n_histograms</span><span class="o">=</span><span class="n">n_pixels</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now we start the scanner and wait until the scan is completed. During the scan, we can read the current data and display it in real time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">scanner</span><span class="o">.</span><span class="n">isScanning</span><span class="p">():</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">flim</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span>
    <span class="n">img3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">,</span> <span class="n">nx_pix</span><span class="p">,</span> <span class="n">ny_pix</span><span class="p">)</span> <span class="c1"># Fluorescence image cube</span>

    <span class="c1"># User defined function that estimates fluorescence lifetime for every pixel</span>
    <span class="n">flimg</span> <span class="o">=</span> <span class="n">get_lifetime</span><span class="p">(</span><span class="n">img3D</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">flimg</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="alternative-pixel-trigger-formats">
<span id="id1"></span><h2>Alternative pixel trigger formats<a class="headerlink" href="#alternative-pixel-trigger-formats" title="Permalink to this heading"></a></h2>
<p>What if a piezo-scanner provides a different trigger signal compared to considered in the previous sections? In this section, we look into a few common types of trigger signals and how to adapt our data acquisition to make them work.</p>
<section id="pixel-pulse-width-defines-the-integration-time">
<h3>Pixel pulse width defines the integration time<a class="headerlink" href="#pixel-pulse-width-defines-the-integration-time" title="Permalink to this heading"></a></h3>
<figure class="align-center">
<img alt="../_images/ConfocalMicroscope-1.svg" class="plot-directive" src="../_images/ConfocalMicroscope-1.svg" /></figure>
<p>The case when the pulse width defines the integration time has been considered in the previous subsections.</p>
</section>
<section id="pixel-pulse-indicates-the-pixel-start">
<h3>Pixel pulse indicates the pixel start<a class="headerlink" href="#pixel-pulse-indicates-the-pixel-start" title="Permalink to this heading"></a></h3>
<figure class="align-center">
<img alt="../_images/ConfocalMicroscope-2.svg" class="plot-directive" src="../_images/ConfocalMicroscope-2.svg" /></figure>
<p>When a pixel pulse has a duration different from the desired integration time, we must define the integration time manually.
One way would be to record all events until the next pixel pulse and rely on a strictly fixed pixel pulse period. Alternatively, we can create a well-defined time window after each pixel pulse, so the measurement system becomes insensitive to the variation of the pixel pulse period.</p>
<p>One can define the time window using the <a class="reference internal" href="../api/VirtualChannels.html#DelayedChannel" title="DelayedChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DelayedChannel</span></code></a> which provides a delayed copy of the leading edge for the pixel pulse.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integr_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e10</span><span class="p">)</span>  <span class="c1"># Integration time of 10 ms in picoseconds</span>
<span class="n">delayed_vch</span> <span class="o">=</span> <span class="n">DelayedChannel</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">PIXEL_START_CH</span><span class="p">,</span> <span class="n">integr_time</span><span class="p">)</span>
<span class="n">PIXEL_END_CH</span> <span class="o">=</span> <span class="n">delayed_vch</span><span class="o">.</span><span class="n">getChannel</span><span class="p">()</span>

<span class="n">cbm</span> <span class="o">=</span> <span class="n">CountBetweenMarkers</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">SPD_CH</span><span class="p">,</span> <span class="n">PIXEL_CH</span><span class="p">,</span> <span class="n">PIXEL_END_CH</span><span class="p">,</span> <span class="n">n_pixels</span><span class="p">)</span>
</pre></div>
</div>
<p>The approach with using <a class="reference internal" href="../api/VirtualChannels.html#DelayedChannel" title="DelayedChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DelayedChannel</span></code></a> allows for a constant integration time per pixel even if the pixel pulses do not occur at a fixed period. For instance, in a raster scan, more time is required to move to the beginning of the next line (fly-back time) compared to the pixel time.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You have to make sure that pixel pulses do not appear before the end of the integration time for the previous pixel.</p>
</div>
</section>
<section id="flim-with-non-periodic-pixel-trigger">
<h3>FLIM with non-periodic pixel trigger<a class="headerlink" href="#flim-with-non-periodic-pixel-trigger" title="Permalink to this heading"></a></h3>
<figure class="align-center">
<img alt="../_images/ConfocalMicroscope-3.svg" class="plot-directive" src="../_images/ConfocalMicroscope-3.svg" /></figure>
<p>In some cases, a scanner generates the pixel pulses with no strictly defined period.
However, most scanning measurements require constant integration time for every pixel. Compared to <a class="reference internal" href="../api/Measurements.html#CountBetweenMarkers" title="CountBetweenMarkers"><code class="xref py py-class docutils literal notranslate"><span class="pre">CountBetweenMarkers</span></code></a>, the <a class="reference internal" href="../api/Measurements.html#TimeDifferences" title="TimeDifferences"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDifferences</span></code></a> measurement do not have a <cite>PIXEL_END</cite> marker and accumulate the histogram for every pixel until the next pixel pulse is received. If this behavior is undesired, or if your pixel pulses are not periodic, you will need to gate your detector to guarantee a constant integration time.</p>
<p>The Time Tagger library provides you with the necessary tools to enforce a fixed integration time when using the <a class="reference internal" href="../api/Measurements.html#TimeDifferences" title="TimeDifferences"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDifferences</span></code></a> measurement. Gating the detector events can be done with the <a class="reference internal" href="../api/VirtualChannels.html#GatedChannel" title="GatedChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GatedChannel</span></code></a>. The example code is provided below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">integr_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e10</span><span class="p">)</span>  <span class="c1"># Integration time of 10 ms in picoseconds</span>
<span class="n">delayed_vch</span> <span class="o">=</span> <span class="n">DelayedChannel</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">PIXEL_START_CH</span><span class="p">,</span> <span class="n">integr_time</span><span class="p">)</span>
<span class="n">PIXEL_END_CH</span> <span class="o">=</span> <span class="n">delayed_vch</span><span class="o">.</span><span class="n">getChannel</span><span class="p">()</span>

<span class="n">gated_vch</span> <span class="o">=</span> <span class="n">GatedChannel</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">SPD_CH</span><span class="p">,</span> <span class="n">PIXEL_START_CH</span><span class="p">,</span> <span class="n">PIXEL_END_CH</span><span class="p">)</span>
<span class="n">GATED_SPD_CH</span> <span class="o">=</span> <span class="n">gated_vch</span><span class="o">.</span><span class="n">getChannel</span><span class="p">()</span>

<span class="n">flim</span> <span class="o">=</span> <span class="n">TimeDifferences</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span>
    <span class="n">click_channel</span><span class="o">=</span><span class="n">GATED_SPD_CH</span><span class="p">,</span>
    <span class="n">start_channel</span><span class="o">=</span><span class="n">LASER_CH</span><span class="p">,</span>
    <span class="n">next_channel</span><span class="o">=</span><span class="n">PIXEL_START_CH</span><span class="p">,</span>
    <span class="n">binwidth</span><span class="o">=</span><span class="n">binwidth</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span>
    <span class="n">n_histograms</span><span class="o">=</span><span class="n">n_pixels</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="line-pulse-but-no-pixel-pulses">
<h3>Line pulse but no pixel pulses<a class="headerlink" href="#line-pulse-but-no-pixel-pulses" title="Permalink to this heading"></a></h3>
<blockquote>
<div><figure class="align-center">
<img alt="../_images/ConfocalMicroscope-4.svg" class="plot-directive" src="../_images/ConfocalMicroscope-4.svg" /></figure>
</div></blockquote>
<p>When a scanning system only has the line-start signal and does not provide the pixel pulses, we have to define time intervals for each pixel by other means.
The pixel markers can be easily generated with <a class="reference internal" href="../api/VirtualChannels.html#EventGenerator" title="EventGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventGenerator</span></code></a> virtual channel which generates events at times relative to the trigger event.
Furthermore, the <a class="reference internal" href="../api/VirtualChannels.html#EventGenerator" title="EventGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventGenerator</span></code></a> allows you to generate not only pixel markers that are equally spaced but also pixels that are
spaced non-uniformly or have time varying integration times. For instance, you will find the <a class="reference internal" href="../api/VirtualChannels.html#EventGenerator" title="EventGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventGenerator</span></code></a> particularly powerful, if you work with
resonant galvo-scanners and need to correct integration time and pixel spacing according to the speed profile of your scanner.
The example below shows how to apply <a class="reference internal" href="../api/VirtualChannels.html#EventGenerator" title="EventGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventGenerator</span></code></a> for generation of pixel markers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nx_pix</span> <span class="o">=</span> <span class="mi">300</span>                <span class="c1"># Number of pixels along x-axis</span>
<span class="n">ny_pix</span> <span class="o">=</span> <span class="mi">200</span>                <span class="c1"># Number of pixels/lines along y-axis</span>
<span class="n">integr_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">3e9</span><span class="p">)</span>      <span class="c1"># Integration time of 3 ms in picoseconds</span>
<span class="n">line_duration</span> <span class="o">=</span> <span class="mf">1e12</span>        <span class="c1"># Duration of the line scan in picoseconds</span>
<span class="n">binwidth</span> <span class="o">=</span> <span class="mi">50</span>               <span class="c1"># in picoseconds</span>
<span class="n">n_bins</span> <span class="o">=</span> <span class="mi">2000</span>               <span class="c1"># number of bins in a histogram</span>
<span class="n">n_pixels</span> <span class="o">=</span> <span class="n">nx_pix</span> <span class="o">*</span> <span class="n">ny_pix</span>  <span class="c1"># number of histograms</span>

<span class="n">LINE_START_CH</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># Pixels are equally spaced in time (constant speed)</span>
<span class="n">pixel_start_times</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">line_duration</span><span class="p">,</span> <span class="n">nx_pix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
<span class="c1"># Pixel integration time is constant</span>
<span class="n">pixel_stop_times</span> <span class="o">=</span> <span class="n">pixel_start_times</span> <span class="o">+</span> <span class="n">integr_time</span>

<span class="c1"># Create EventGenerator channels</span>
<span class="n">pixel_start_vch</span> <span class="o">=</span> <span class="n">EventGenerator</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">LINE_START_CH</span><span class="p">,</span> <span class="n">pixel_start_times</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
<span class="n">pixel_stop_vch</span> <span class="o">=</span> <span class="n">EventGenerator</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">LINE_START_CH</span><span class="p">,</span> <span class="n">pixel_stop_times</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

<span class="n">PIXEL_START_CH</span> <span class="o">=</span> <span class="n">pixel_start_vch</span><span class="o">.</span><span class="n">getChannel</span><span class="p">()</span>
<span class="n">PIXEL_END_CH</span> <span class="o">=</span> <span class="n">pixel_stop_vch</span><span class="o">.</span><span class="n">getChannel</span><span class="p">()</span>

<span class="c1"># Use GatedChannel to gate the detector</span>
<span class="n">gated_vch</span> <span class="o">=</span> <span class="n">GatedChannel</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">SPD_CH</span><span class="p">,</span> <span class="n">PIXEL_START_CH</span><span class="p">,</span> <span class="n">PIXEL_END_CH</span><span class="p">)</span>
<span class="n">GATED_SPD_CH</span> <span class="o">=</span> <span class="n">gated_vch</span><span class="o">.</span><span class="n">getChannel</span><span class="p">()</span>

<span class="n">flim</span> <span class="o">=</span> <span class="n">TimeDifferences</span><span class="p">(</span>
    <span class="n">tt</span><span class="p">,</span>
    <span class="n">click_channel</span><span class="o">=</span><span class="n">GATED_SPD_CH</span><span class="p">,</span>
    <span class="n">start_channel</span><span class="o">=</span><span class="n">LASER_CH</span><span class="p">,</span>
    <span class="n">next_channel</span><span class="o">=</span><span class="n">PIXEL_START_CH</span><span class="p">,</span>
    <span class="n">binwidth</span><span class="o">=</span><span class="n">binwidth</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span>
    <span class="n">n_histograms</span><span class="o">=</span><span class="n">n_pixels</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the TimeTagger software v2.7.2 we have completely redesigned <a class="reference internal" href="../api/Measurements.html#Flim" title="Flim"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flim</span></code></a>
measurement. It support easy interface similar to <a class="reference internal" href="../api/Measurements.html#TimeDifferences" title="TimeDifferences"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDifferences</span></code></a>, as well as
high-performance frame streaming interface that allows for real-time video-rate FLIM imaging.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Tutorials" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="TimeTaggerRPC.html" class="btn btn-neutral float-right" title="Remote Time Tagger with Python" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Swabian Instruments.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>